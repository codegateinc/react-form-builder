{"version":3,"file":"react-form-builder.cjs.production.min.js","sources":["../src/types/Form.ts","../src/stores/formStore/formStore.ts","../src/stores/configStore/configStore.ts","../src/stores/index.ts","../src/hooks/useValidate.ts","../src/hooks/useEvents.ts","../src/hooks/useBlur.ts","../src/hooks/useChange.ts","../src/utils/stateUtils.ts","../src/components/Input.tsx","../src/components/Checkbox.tsx","../src/components/Picker.tsx","../src/Form.tsx","../src/utils/renderHelpers.tsx","../src/FormProvider.tsx","../src/hooks/useForm.ts"],"sourcesContent":["import { FormState } from './FormState'\nimport { KeyValuePair } from './common'\n\nexport enum FormFieldType {\n    Input = 0,\n    Picker = 1,\n    CheckBox = 2\n}\n\ntype ValidationValue = string | number | boolean | Array<FormOption>\n\nexport type FormValidationRule = {\n    errorMessage: string,\n    validationFunction(value: ValidationValue, form: FormState): boolean\n}\n\nexport type FormOptionValue = number | string\n\nexport type FormOption = {\n    value: FormOptionValue,\n    label: string,\n    isSelected?: boolean\n}\n\nexport type FieldConfig = {\n    value?: string | number | boolean,\n    type: FormFieldType,\n    isRequired?: boolean,\n    validationRules?: Array<FormValidationRule>,\n    options?: Array<FormOption>,\n    disabled?: boolean,\n    liveParser?(value: ValidationValue): ValidationValue,\n    forceLiveValidate?: boolean\n}\n\nexport type FormConfig = KeyValuePair<FieldConfig>\n// tslint:disable-next-line:no-any\nexport type OnSuccess = (form: any) => void\nexport type OnError = (errors: Array<KeyValuePair>) => void\nexport type FormProps = {\n    formName: string\n}\nexport type OnUpdate = (form: any) => void\n\nexport interface UseFormProps extends FormProps {\n    formConfig: FormConfig,\n    onSuccess?: OnSuccess,\n    onError?: OnError,\n    onUpdate?: OnUpdate\n}\n","import { useEffect, useState } from 'react'\nimport { G } from '@codegateinc/g-utils'\nimport { FieldConfig, FormFieldType, FormOption, FormPickerState, FormState, SubscribeOnChange } from '../../types'\n\nexport type FormStoreState = {\n    [key: string]: FormState\n}\n\ntype OnChange = {\n    [key: string]: SubscribeOnChange\n}\n\ntype FormStoreOnChange = {\n    [key: string]: OnChange\n}\n\nexport const formStore = () => {\n    const [ formState, setFormState ] = useState<FormStoreState>({})\n    const [ onChangeForm, setOnChangeForm ] = useState<FormStoreOnChange>({})\n\n    return {\n        actions: {\n            setFormState: (key: string, state: FormState) => setFormState(prevState => ({\n                ...prevState,\n                [key]: state\n            })),\n            setFormValue: (formKey: string, key: string, value: string | boolean, callback?: (state: FormState) => void) => {\n                if (!formState[formKey]) {\n                    return\n                }\n\n                const newState = {\n                    ...formState,\n                    [formKey]: {\n                        ...formState[formKey],\n                        [key]: {\n                            ...formState[formKey][key],\n                            value\n                        }\n                    }\n                }\n\n                setFormState(prevState => ({\n                    ...prevState,\n                    [formKey]: {\n                        ...prevState[formKey],\n                        [key]: {\n                            ...prevState[formKey][key],\n                            value\n                        }\n                    }\n                }))\n\n                G.ifDefined(callback, fn => fn(newState[formKey]))\n\n                if (onChangeForm[formKey] && onChangeForm[formKey][key]) {\n                    onChangeForm[formKey][key](value)\n                }\n            },\n            setFormError: (formKey: string, key: string, errorMessage?: string) => formState[formKey] && setFormState(prevState => ({\n                ...prevState,\n                [formKey]: {\n                    ...prevState[formKey],\n                    [key]: {\n                        ...prevState[formKey][key],\n                        errorMessage\n                    }\n                }\n            })),\n            setFormPristine: (formKey: string, key: string, isPristine: boolean) => formState[formKey] && setFormState(prevState => ({\n                ...prevState,\n                [formKey]: {\n                    ...prevState[formKey],\n                    [key]: {\n                        ...prevState[formKey][key],\n                        isPristine\n                    }\n                }\n            })),\n            setFormOptions: (\n                formKey: string,\n                key: string,\n                newOptions: Array<FormOption>,\n                callback?: (state: FormState) => void\n            ) => {\n                if (!formState[formKey]) {\n                    return\n                }\n\n                const newState = () => {\n                    const options = newOptions\n                        .map(option => option.value)\n                    const changedOptions = (formState[formKey][key] as FormPickerState).options\n                        .map(option => ({\n                            ...option,\n                            isSelected: options.includes(option.value)\n                        }))\n\n                    return {\n                        ...formState,\n                        [formKey]: {\n                            ...formState[formKey],\n                            [key]: {\n                                ...formState[formKey][key],\n                                options: changedOptions\n                            }\n                        }\n                    }\n                }\n\n                setFormState(prevState => {\n                    const options = newOptions\n                        .map(option => option.value)\n                    const changedOptions = (prevState[formKey][key] as FormPickerState).options\n                        .map(option => ({\n                            ...option,\n                            isSelected: options.includes(option.value)\n                        }))\n\n                    if (onChangeForm[formKey] && onChangeForm[formKey][key]) {\n                        onChangeForm[formKey][key](changedOptions)\n                    }\n\n                    return {\n                        ...prevState,\n                        [formKey]: {\n                            ...prevState[formKey],\n                            [key]: {\n                                ...prevState[formKey][key],\n                                options: changedOptions\n                            }\n                        }\n                    }\n                })\n                G.ifDefined(callback, fn => fn(newState()[formKey]))\n            },\n            setFormField: (formKey: string, key: string, field: Omit<FieldConfig, 'type'>) => {\n                if (formState[formKey] && formState[formKey][key]) {\n                    setFormState(prevState => ({\n                        ...prevState,\n                        [formKey]: {\n                            ...prevState[formKey],\n                            [key]: {\n                                ...formState[formKey][key],\n                                ...field,\n                                type: formState[formKey][key].type,\n                                options: field.options || (formState[formKey][key].type === FormFieldType.Picker\n                                    ? (formState[formKey][key] as FormPickerState).options\n                                    : []\n                                )\n                            }\n                        }\n                    }))\n                }\n            },\n            getFormField: (formKey: string, key: string) => {\n                if (formState[formKey] && formState[formKey][key]) {\n                    return formState[formKey][key]\n                }\n\n                return {}\n            },\n            onFormFieldChange: (formKey: string, formFieldName: string, onChange: SubscribeOnChange) => {\n                useEffect(() => {\n                    setOnChangeForm(prevState => ({\n                        ...prevState,\n                        [formKey]: {\n                            ...prevState[formKey],\n                            [formFieldName]: onChange\n                        }\n                    }))\n                }, [formState])\n            },\n            clearFormStore: (formKey: string) => {\n                setFormState(prevState => ({\n                    ...prevState,\n                    [formKey]: {}\n                }))\n                setOnChangeForm(prevState => ({\n                    ...prevState,\n                    [formKey]: {}\n                }))\n            }\n        },\n        state: {\n            formState\n        }\n    }\n}\n","import { useState } from 'react'\nimport { FormConfig, OnUpdate, FieldConfig, FormFieldType } from '../../types'\n\nexport type ConfigStoreState = {\n    [key: string]: FormConfig\n}\n\nexport type ConfigOnUpdate = {\n    [key: string]: OnUpdate\n}\n\nexport const configStore = () => {\n    const [ configStore, setConfig ] = useState<ConfigStoreState>({})\n    const [ configOnUpdate, setConfigOnUpdate ] = useState<ConfigOnUpdate>({})\n\n    return {\n        actions: {\n            setConfig: (key: string, newConfig: FormConfig) => setConfig(prevState => ({\n                ...prevState,\n                [key]: newConfig\n            })),\n            clearConfigStore: (formKey: string) => setConfig(prevState => ({\n                ...prevState,\n                [formKey]: {}\n            })),\n            setOnUpdate: (key: string, onUpdate?: OnUpdate) => onUpdate && setConfigOnUpdate(prevState => ({\n                ...prevState,\n                [key]: onUpdate\n            })),\n            setConfigFormField: (formKey: string, key: string, field: Omit<FieldConfig, 'type'>) => {\n                if (configStore[formKey] && configStore[formKey][key]) {\n                    setConfig(prevState => ({\n                        ...prevState,\n                        [formKey]: {\n                            ...prevState[formKey],\n                            [key]: {\n                                ...configStore[formKey][key],\n                                ...field,\n                                type: configStore[formKey][key].type,\n                                options: field.options || (configStore[formKey][key].type === FormFieldType.Picker\n                                    ? configStore[formKey][key].options\n                                    : []\n                                )\n                            }\n                        }\n                    }))\n                }\n            }\n        },\n        state: {\n            configStore,\n            configOnUpdate\n        }\n    }\n}\n","import { formStore } from './formStore'\nimport { configStore } from './configStore'\n\nexport const formBuilderStores = [\n    configStore,\n    formStore\n]\n\nexport {\n    configStore,\n    formStore\n}\n","import { useStore } from 'outstated'\nimport { G } from '@codegateinc/g-utils'\nimport { configStore, formStore } from '../stores'\nimport { FieldState, FormCheckBoxState, FormFieldType, FormInputState, FormOption, FormPickerState } from '../types'\n\nexport const useValidate = () => {\n    const form = useStore(formStore)\n    const config = useStore(configStore)\n\n    return {\n        validateField: (formName: string, key: string, value: string) => {\n            const field = config.state.configStore &&\n                config.state.configStore[formName] &&\n                config.state.configStore[formName][key]\n\n            if (field?.validationRules) {\n                const validated = field.validationRules\n                    .map(rule => rule.validationFunction(value, form.state.formState[formName])\n                        ? rule.errorMessage\n                        : undefined\n                    )\n                const [ errorMessage ] = validated\n                    .filter(value => value)\n\n                form.actions.setFormError(formName, key, errorMessage)\n            }\n        },\n        validateCheckBox: (formName: string, key: string, value: boolean) => {\n            const field = config.state.configStore &&\n                config.state.configStore[formName] &&\n                config.state.configStore[formName][key]\n\n            if (field?.validationRules) {\n                const [ rule ] = field.validationRules\n                const errorMessage = rule.validationFunction(value, form.state.formState[formName])\n                    ? rule.errorMessage\n                    : undefined\n\n                form.actions.setFormError(formName, key, errorMessage)\n            }\n        },\n        validatePicker: (formName: string, key: string, options: Array<FormOption>) => {\n            const field = config.state.configStore &&\n                config.state.configStore[formName] &&\n                config.state.configStore[formName][key]\n            const validated = field?.validationRules && field.validationRules\n                .map(rule => rule.validationFunction(options, form.state.formState[formName])\n                    ? rule.errorMessage\n                    : undefined\n                )\n            const [ errorMessage ] = validated || [undefined]\n                .filter(value => value)\n            const isAnyOptionSelected = field?.options && field.options\n                .some(option => option.isSelected)\n\n            if (field?.isRequired && isAnyOptionSelected) {\n                return form.actions.setFormError(formName, key, undefined)\n            }\n\n            form.actions.setFormError(formName, key, errorMessage)\n        },\n        validateForm: (formName: string, shouldUpdateStore: boolean = true) => form.state.formState[formName] ? G.toPairs<FieldState>(form.state.formState[formName])\n            .map(([key, formState]) => {\n                const configField = config.state.configStore && config.state.configStore[formName][key]\n\n                if (configField?.validationRules && formState.type === FormFieldType.Input) {\n                    const value = (formState as FormInputState).value\n\n                    if (!formState.isRequired && value === '') {\n                        return undefined\n                    }\n\n                    const validated = configField.validationRules\n                        .map(rule => rule.validationFunction(value, form.state.formState[formName])\n                            ? rule.errorMessage\n                            : undefined\n                        )\n                    const [ errorMessage ] = validated\n                        .filter(value => value)\n\n                    if (shouldUpdateStore) {\n                        form.actions.setFormError(formName, key, errorMessage)\n                    }\n\n                    return errorMessage\n                }\n\n                if (configField?.validationRules && formState.type === FormFieldType.CheckBox) {\n                    const value = (formState as FormCheckBoxState).value\n\n                    if (!formState.isRequired) {\n                        return undefined\n                    }\n\n                    const [ rule ] = configField.validationRules\n                    const errorMessage = rule.validationFunction(value, form.state.formState[formName])\n                        ? rule.errorMessage\n                        : undefined\n\n                    if (shouldUpdateStore) {\n                        form.actions.setFormError(formName, key, errorMessage)\n                    }\n\n                    return errorMessage\n                }\n\n                if (configField?.validationRules && formState.type === FormFieldType.Picker) {\n                    const options = (formState as FormPickerState).options\n\n                    if (!formState.isRequired) {\n                        return undefined\n                    }\n\n                    const validated = configField.validationRules\n                        .map(rule => rule.validationFunction(options, form.state.formState[formName])\n                            ? rule.errorMessage\n                            : undefined\n                        )\n                    const [ errorMessage ] = validated\n                        .filter(value => value)\n\n                    if (shouldUpdateStore) {\n                        form.actions.setFormError(formName, key, errorMessage)\n                    }\n\n                    return errorMessage\n                }\n            }) : []\n    }\n}\n","import { useBlur } from './useBlur'\nimport { useChange } from './useChange'\n\nexport const useEvents = () => {\n    const { onInputBlur } = useBlur()\n    const { onInputChange, onCheckboxChange, onPickerChange } = useChange()\n\n    return {\n        input: {\n            onBlur: onInputBlur,\n            onChange: onInputChange\n        },\n        checkBox: {\n            onChange: onCheckboxChange\n        },\n        picker: {\n            onChange: onPickerChange\n        }\n    }\n}\n","import { useStore } from 'outstated'\nimport { useValidate } from './useValidate'\nimport { configStore, formStore } from '../stores'\n\nexport const useBlur = () => {\n    const form = useStore(formStore)\n    const config = useStore(configStore)\n    const { validateField } = useValidate()\n\n    return {\n        onInputBlur: (formName: string, key: string, value: string) => {\n            const field = form.state.formState[formName][key]\n            const configField = config.state.configStore && config.state.configStore[formName][key]\n\n            if (field.isRequired || value !== configField?.value) {\n                form.actions.setFormPristine(formName, key, false)\n            }\n\n            validateField(formName, key, value)\n        }\n    }\n}\n","import { useStore } from 'outstated'\nimport { G } from '@codegateinc/g-utils'\nimport { useValidate } from './useValidate'\nimport { configStore, formStore } from '../stores'\nimport { FormCheckBoxState, FormInputState, FormOption, FormState } from '../types'\n\nexport const useChange = () => {\n    const { state, actions } = useStore(formStore)\n    const form = useStore(configStore)\n    const { validateField, validateCheckBox, validatePicker } = useValidate()\n\n    return {\n        onInputChange: (formName: string, key: string, value: string, callback?: (state: FormState) => void) => {\n            const field = state.formState[formName][key] as FormInputState\n            const configField = form.state.configStore &&\n                form.state.configStore[formName] &&\n                form.state.configStore[formName][key]\n\n            const parsedValue = configField?.liveParser\n                ? configField.liveParser(value)\n                : value\n\n            if (typeof parsedValue !== 'string') {\n                throw new Error('liveParser must return string on input')\n            }\n\n            const shouldValidateField = field.errorMessage || !field.isPristine || configField.forceLiveValidate\n\n            if (shouldValidateField) {\n                validateField(formName, key, parsedValue)\n            }\n\n            actions.setFormValue(formName, key, parsedValue, callback)\n        },\n        onCheckboxChange: (formName: string, key: string, callback?: (state: FormState) => void) => {\n            const field = state.formState[formName][key] as FormCheckBoxState\n            const configField = form.state.configStore &&\n                form.state.configStore[formName] &&\n                form.state.configStore[formName][key]\n\n            const parsedValue = configField?.liveParser\n                ? configField.liveParser(!field.value)\n                : !field.value\n\n            if (typeof parsedValue !== 'boolean') {\n                throw new Error('liveParser must return boolean on checkbox')\n            }\n\n            if ((field.isRequired && !field.isPristine) || field.errorMessage || configField.validationRules) {\n                validateCheckBox(formName, key, parsedValue)\n            }\n\n            actions.setFormValue(formName, key, parsedValue, callback)\n        },\n        onPickerChange: (formName: string, key: string, options: Array<FormOption>, callback?: (state: FormState) => void) => {\n            const configField = form.state.configStore &&\n                form.state.configStore[formName] &&\n                form.state.configStore[formName][key]\n            const valuedOptions = options.map(item => item.value)\n            const fullOptions = configField?.options?.map(option => ({\n                ...option,\n                isSelected: valuedOptions.includes(option.value)\n            }))\n\n            const parsedOptions = configField?.liveParser\n                ? configField.liveParser(options)\n                : options\n\n            if (!G.is(Array, parsedOptions)) {\n                throw new Error('liveParser must return array on picker')\n            }\n\n            validatePicker(formName, key, fullOptions || [])\n            actions.setFormOptions(formName, key, parsedOptions as Array<FormOption>, callback)\n        }\n    }\n}\n","import { G } from '@codegateinc/g-utils'\nimport {\n    FieldConfig,\n    FieldState,\n    FormCheckBoxState,\n    FormConfig,\n    FormFieldType,\n    FormInputState,\n    FormPickerState,\n    FormState\n} from 'types'\n\nexport const prepareFormInitialState = (formConfig: FormConfig, clearForm: boolean = false) => {\n    const configToPairs = G.toPairs<FieldConfig>(formConfig)\n        .map(([ fieldName, config ]) => {\n            if (config?.isRequired && !config?.validationRules) {\n                throw new Error('validationRules are required if field isRequired  ')\n            }\n\n            if (config.type === FormFieldType.Input) {\n                return [fieldName, {\n                    value: clearForm\n                        ? ''\n                        : config.value || '',\n                    isRequired: config?.isRequired || false,\n                    isPristine: true,\n                    disabled: config?.disabled || false,\n                    type: config.type,\n                    errorMessage: undefined\n                }]\n            }\n\n            if (config.type === FormFieldType.CheckBox) {\n                return [fieldName, {\n                    value: clearForm\n                        ? false\n                        : config.value || false,\n                    isRequired: config?.isRequired || false,\n                    isPristine: true,\n                    disabled: config?.disabled || false,\n                    type: config.type,\n                    errorMessage: undefined\n                }]\n            }\n\n            if (config.type === FormFieldType.Picker) {\n                return [fieldName, {\n                    isRequired: config?.isRequired || false,\n                    isPristine: true,\n                    disabled: config?.disabled || false,\n                    type: config.type,\n                    errorMessage: undefined,\n                    options: clearForm\n                        ? config.options?.map(option => ({\n                            ...option,\n                            isSelected: false\n                        })) || []\n                        : config.options || []\n                }]\n            }\n        }) as Array<[string, FieldState]>\n\n    return G.fromPairs(configToPairs)\n}\n\nexport const parseForm = (state: FormState) => state && G.toPairs<FieldState>(state)\n    .reduce((acc, [key, object]) => {\n        if (object.type === FormFieldType.Input || object.type === FormFieldType.CheckBox) {\n            const value = (object as FormInputState | FormCheckBoxState).value\n\n            return {\n                ...acc,\n                [key]: value\n            }\n        }\n\n        if (object.type === FormFieldType.Picker) {\n            const options = (object as FormPickerState).options\n                .filter(option => option.isSelected)\n                .map(option => option.value)\n\n            return {\n                ...acc,\n                [key]: options\n            }\n        }\n\n        return acc\n    }, {})\n","import React from 'react'\nimport { InputProps } from '../types'\n\n// @ts-ignore\nexport const Input: React.FunctionComponent<InputProps> = ({ component }) => component()\n","import React from 'react'\nimport { CheckBoxProps } from '../types'\n\n// @ts-ignore\nexport const CheckBox: React.FunctionComponent<CheckBoxProps> = ({ component }) => component()\n","import React from 'react'\nimport { PickerProps } from '../types'\n\n// @ts-ignore\nexport const Picker: React.FunctionComponent<PickerProps> = ({ component }) => component()\n","import React, { Fragment } from 'react'\nimport { renderForm } from 'utils'\nimport { FormProps } from './types'\n\nexport const Form: React.FunctionComponent<FormProps> = ({\n    children,\n    formName\n}) => (\n    <Fragment>\n        {renderForm(children, formName)}\n    </Fragment>\n)\n","import React from 'react'\nimport { G } from '@codegateinc/g-utils'\nimport { useStore } from 'outstated'\nimport { useEvents } from 'hooks/useEvents'\nimport { configStore, formStore } from 'stores'\nimport {\n    FormOption,\n    InputProps,\n    PickerProps,\n    CheckBoxProps,\n    FormFieldType,\n    FormInputState,\n    FormPickerState,\n    FormCheckBoxState\n} from '../types'\nimport { parseForm } from './stateUtils'\nimport { FieldConfig } from 'types/Form'\n\nexport const renderForm = (\n    children: React.ReactNode,\n    formName: string\n) => {\n    if (!children) {\n        throw new Error('children are mandatory')\n    }\n\n    return React.Children.map(children, child => renderChild(child, formName))\n}\n\nconst renderChild = (child: React.ReactNode, formName: string) => {\n    if (typeof child === 'string' || typeof child === 'number' || typeof child === null) {\n        return child\n    }\n\n    const { state } = useStore(formStore)\n    const { state: { configOnUpdate, configStore: config } } = useStore(configStore)\n\n    // tslint:disable-next-line:no-any\n    const reactElementChild = child as React.ReactElement<any>\n    const form = config[formName]\n    const elType = form\n        ? (form[reactElementChild.props.formFieldName] as FieldConfig)?.type\n        : undefined\n\n    if (elType === FormFieldType.Input) {\n        const { input } = useEvents()\n        const inputChild = child as React.ReactElement<InputProps>\n        const key = inputChild.props.formFieldName\n        const formState = state.formState[formName]\n        const inputState = formState ? formState[key] as FormInputState : undefined\n\n        return React.cloneElement<InputProps>(inputChild, {\n            ...inputChild.props,\n            component: () => inputChild.props.component({\n                value: inputState?.value || '',\n                onChangeText: text => input.onChange(formName, key, text, state => {\n                    G.ifDefined(configOnUpdate[formName], fn => fn(parseForm(state)))\n                }),\n                onBlur: () => input.onBlur(formName, key, inputState?.value || ''),\n                errorMessage: inputState?.errorMessage,\n                disabled: inputState?.disabled || false,\n                isPristine: inputState?.isPristine || true\n            })\n        })\n    }\n\n    if (elType === FormFieldType.CheckBox) {\n        const { checkBox } = useEvents()\n        const checkBoxChild = child as React.ReactElement<CheckBoxProps>\n        const key = checkBoxChild.props.formFieldName\n        const formState = state.formState[formName]\n        const checkBoxState = formState ? formState[key] as FormCheckBoxState : undefined\n\n        return React.cloneElement<CheckBoxProps>(checkBoxChild, {\n            ...checkBoxChild.props,\n            component: () => checkBoxChild.props.component({\n                value: checkBoxState?.value || false,\n                onChange: () => checkBox.onChange(formName, key, state => {\n                    G.ifDefined(configOnUpdate[formName], fn => fn(parseForm(state)))\n                }),\n                errorMessage: checkBoxState?.errorMessage,\n                disabled: checkBoxState?.disabled || false,\n                isPristine: checkBoxState?.isPristine || true\n            })\n        })\n    }\n\n    if (elType === FormFieldType.Picker) {\n        const { picker } = useEvents()\n        const pickerChild = child as React.ReactElement<PickerProps>\n        const key = pickerChild.props.formFieldName\n        const formState = state.formState[formName]\n        const pickerState = formState ? formState[key] as FormPickerState : undefined\n\n        return React.cloneElement<PickerProps>(pickerChild, {\n            ...pickerChild.props,\n            component: () => pickerChild.props.component({\n                onChange: (options: Array<FormOption>) => picker.onChange(formName, key, options, state => {\n                    G.ifDefined(configOnUpdate[formName], fn => fn(parseForm(state)))\n                }),\n                errorMessage: pickerState?.errorMessage,\n                disabled: pickerState?.disabled || false,\n                isPristine: pickerState?.isPristine || true,\n                options: pickerState?.options || []\n            })\n        })\n    }\n\n    const reactElementChildren = reactElementChild.props.children\n\n    if (reactElementChildren) {\n        const newChildren = React.Children.map(reactElementChildren, child => renderChild(child, formName))\n\n        return React.cloneElement(reactElementChild, reactElementChild.props, newChildren)\n    }\n\n    return reactElementChild\n}\n","import React from 'react'\nimport { Provider } from 'outstated'\nimport { formBuilderStores } from './stores'\n\nexport const FormProvider: React.FunctionComponent = ({ children }) => (\n    <Provider stores={formBuilderStores}>\n        {children}\n    </Provider>\n)\n","import { useEffect } from 'react'\nimport { useStore } from 'outstated'\nimport { G } from '@codegateinc/g-utils'\nimport { parseForm, prepareFormInitialState } from 'utils'\nimport { configStore, formStore } from 'stores'\nimport {\n    FieldState,\n    FieldConfig,\n    UseFormProps,\n    SubscribeOnChange\n} from 'types'\nimport { useValidate } from './useValidate'\n\nexport const useForm = <T>({\n    formName,\n    formConfig,\n    onError,\n    onSuccess,\n    onUpdate\n}: UseFormProps) => {\n    const { state, actions } = useStore(formStore)\n    const config = useStore(configStore)\n    const { validateForm } = useValidate()\n\n    useEffect(() => {\n        const formState = prepareFormInitialState(formConfig)\n\n        config.actions.setConfig(formName, formConfig)\n        config.actions.setOnUpdate(formName, onUpdate)\n        actions.setFormState(formName, formState)\n\n        return () => {\n            config.actions.clearConfigStore(formName)\n            actions.clearFormStore(formName)\n        }\n    }, [])\n\n    return {\n        submitForm: () => {\n            const validated = validateForm(formName)\n\n            const hasAnyError = validated\n                .some(value => value)\n\n            if (hasAnyError) {\n                return G.ifDefined(onError, fn => fn(validated))\n            }\n\n            const parsedForm = parseForm(state.formState[formName])\n\n            return G.ifDefined(onSuccess, fn => fn(parsedForm))\n        },\n        hasChanges: state.formState[formName] && G.toPairs<FieldState>(state.formState[formName])\n            .some(([key, object]) => !object.isPristine),\n        setField: (formFieldName: string, field: Omit<FieldConfig, 'type'>) => {\n            actions.setFormField(formName, formFieldName, field)\n            config.actions.setConfigFormField(formName, formFieldName, field)\n        },\n        isFormValid: !validateForm(formName, false)\n            .some(error => error),\n        getField: (formFieldName: string) => actions.getFormField(formName, formFieldName),\n        subscribe: (formFieldName: string) => ({\n            onChange: <T>(onChange: SubscribeOnChange<T>) => actions.onFormFieldChange(formName, formFieldName, onChange)\n        }),\n        restoreToInitial: () => {\n            if (config.state.configStore) {\n                const newState = prepareFormInitialState(config.state.configStore[formName])\n\n                actions.setFormState(formName, newState)\n\n                G.ifDefined(onUpdate, fn => fn(parseForm(newState)))\n            }\n        },\n        clearForm: () => {\n            if (config.state.configStore) {\n                const newState = prepareFormInitialState(config.state.configStore[formName], true)\n\n                actions.setFormState(formName, newState)\n\n                G.ifDefined(onUpdate, fn => fn(parseForm(newState)))\n            }\n        },\n        setFieldError: (formFieldName: string, errorMessage: string) => actions.setFormError(formName, formFieldName, errorMessage),\n        isFormReady: G.hasKeys(state.formState[formName])\n    }\n}\n"],"names":["FormFieldType","formStore","useState","formState","setFormState","onChangeForm","setOnChangeForm","actions","key","state","prevState","setFormValue","formKey","value","callback","newState","G","ifDefined","fn","setFormError","errorMessage","setFormPristine","isPristine","setFormOptions","newOptions","options","map","option","changedOptions","isSelected","includes","setFormField","field","type","Picker","getFormField","onFormFieldChange","formFieldName","onChange","useEffect","clearFormStore","configStore","setConfig","setConfigOnUpdate","newConfig","clearConfigStore","setOnUpdate","onUpdate","setConfigFormField","configOnUpdate","formBuilderStores","useValidate","form","useStore","config","validateField","formName","validationRules","rule","validationFunction","undefined","filter","validateCheckBox","validatePicker","isAnyOptionSelected","some","isRequired","validateForm","shouldUpdateStore","toPairs","configField","Input","CheckBox","useEvents","onInputBlur","onInputChange","parsedValue","liveParser","Error","forceLiveValidate","onCheckboxChange","onPickerChange","valuedOptions","item","fullOptions","_configField$options","parsedOptions","is","Array","useChange","input","onBlur","checkBox","picker","prepareFormInitialState","formConfig","clearForm","configToPairs","fieldName","disabled","fromPairs","parseForm","reduce","acc","object","component","React","Fragment","children","Children","child","renderChild","reactElementChild","elType","props","_form$reactElementChi","inputChild","inputState","cloneElement","onChangeText","text","checkBoxChild","checkBoxState","pickerChild","pickerState","reactElementChildren","newChildren","renderForm","Provider","stores","onError","onSuccess","submitForm","validated","parsedForm","hasChanges","setField","isFormValid","error","getField","subscribe","restoreToInitial","setFieldError","isFormReady","hasKeys"],"mappings":"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"}